#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Trading Strategy Visualization - DeepLOB trading strategy visualization.
This module enables the visualization of trades generated by the trading strategy with price data.
"""

import os
import time
import numpy as np
import pandas as pd
from plotly.subplots import make_subplots
import plotly.graph_objects as go
from typing import List, Dict, Optional, Union

# Import the trading strategy
from trading_strategy import SimpleTradingStrategy


def plot_trading_strategy(
    strategy: SimpleTradingStrategy,
    title="Price vs. Trading Strategy Performance",
    save_path=None,
    date_range: tuple = None
) -> go.Figure:
    """
    Create a Plotly-based interactive time series chart with price data and the trading strategy's
    winning/losing trades, as well as its cumulative profit.
    
    Args:
        strategy: An initialized and executed SimpleTradingStrategy instance
        title: Chart title
        save_path: Save path (if provided)
        date_range: Optional tuple of (start_datetime, end_datetime) to filter trades by date range
        
    Returns:
        plotly.graph_objects.Figure: The created interactive chart
    """
    # Validation
    if strategy.data is None or len(strategy.trades) == 0:
        raise ValueError("Strategy data is missing or no trades have been generated. "
                        "First run the load_predictions, preprocess_data and generate_trades functions.")
    
    # Create DataFrame
    df = strategy.data.copy()
    
    # Convert trading data to DataFrame
    all_trades_df = pd.DataFrame(strategy.trades)
    
    # Filter by date range if provided
    t_start = time.time()
    print(f"Total number of trades: {len(all_trades_df)}")
    
    if date_range is not None:
        start_date, end_date = date_range
        
        # Convert string dates to pandas datetime if needed
        if isinstance(start_date, str):
            start_date = pd.to_datetime(start_date)
        if isinstance(end_date, str):
            end_date = pd.to_datetime(end_date)
            
        # Filter trades for the specified date range
        trades_df = all_trades_df[
            (all_trades_df['entry_time'] >= start_date) & 
            (all_trades_df['exit_time'] <= end_date)
        ]
        
        # Also filter main dataframe to the date range
        df = df[(df.index >= start_date) & (df.index <= end_date)]
        
        print(f"Filtered to {len(trades_df)} trades in date range ({start_date} to {end_date})")
    else:
        # Use all trades if no date range is specified
        trades_df = all_trades_df.copy()
        
    print(f"Preparation time: {time.time() - t_start:.2f}s")
    
    # A trades_df már csak a kiszűrt kereskedéseket tartalmazza, rendezzük időben
    trades_df = trades_df.sort_values('exit_time')

    # Create chart with two panels
    fig = make_subplots(
        rows=2, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.05,
        row_heights=[0.7, 0.3],
        subplot_titles=("Price with Trades", "Cumulative Return")
    )
    
    # 1st panel: Price line (gray by default, trades will be colored separately)
    fig.add_trace(
        go.Scatter(
            x=df.index,
            y=df['raw_price'],
            mode='lines',
            name='BTC Price (No Trade)',
            line=dict(color='gray', width=1.5),
            hoverinfo='skip',
        ),
        row=1, col=1
    )
    
    # Price with colored segments during trading periods
    winning_segments = []
    losing_segments = []
    no_trade_segments = []
    
    # Also print simple sum return for comparison with strategy.analyze_performance()
    simple_return = all_trades_df['profit_pct'].sum()*100 if len(all_trades_df) > 0 else 0.00
    print(f"Simple-sum return: {simple_return:.2f}% (matches analyze_performance)")
    
    # First sort trades by time
    trades_df = trades_df.sort_values('entry_time')
    
    # Check if DataFrame is empty after date filtering
    if len(df) == 0:
        # Create an empty figure if no data in the selected date range
        fig.update_layout(
            title=title,
            annotations=[{
                'text': "No data available for the selected date range",
                'xref': "paper",
                'yref': "paper",
                'x': 0.5,
                'y': 0.5,
                'showarrow': False,
                'font': {'size': 20}
            }]
        )
        
        if save_path:
            fig.write_html(save_path)
            
        return fig
        
    # Calculate cumulative returns for the filtered trades
    cumulative_returns_data = pd.Series(0, index=df.index)
    for _, trade in trades_df.iterrows():
        # Add the trade's profit to all timestamps after the trade's exit time
        mask = df.index >= trade['exit_time']
        cumulative_returns_data[mask] += trade['profit_pct']
        
    # Initial timestamp
    current_time = df.index[0]
    
    # Process trades
    for _, trade in trades_df.iterrows():
        # From previous timestamp to trade start (if there's a time difference)
        mask = (df.index >= current_time) & (df.index < trade['entry_time'])
        if mask.any():
            segment_x = df.index[mask]
            segment_y = df['raw_price'][mask]
            if len(segment_x) > 0:
                no_trade_segments.append((segment_x, segment_y))
        
        # For the trading period - only if there's data
        mask = (df.index >= trade['entry_time']) & (df.index <= trade['exit_time'])
        if mask.any():
            segment_x = df.index[mask]
            segment_y = df['raw_price'][mask]
            if len(segment_x) > 0:
                if trade['profit_pct'] > 0:
                    winning_segments.append((segment_x, segment_y))
                else:
                    losing_segments.append((segment_x, segment_y))
        
        # Set the current timestamp to the end of the trade
        current_time = trade['exit_time']
    
    # From the end of the last trade to the end of data (if there's still time)
    mask = (df.index >= current_time)
    if mask.any():
        segment_x = df.index[mask]
        segment_y = df['raw_price'][mask]
        if len(segment_x) > 0:
            no_trade_segments.append((segment_x, segment_y))
    
    # Winning trades as green segments
    for i, (segment_x, segment_y) in enumerate(winning_segments):
        # Find the trade corresponding to this segment
        trade_info = None
        for _, trade in trades_df.iterrows():
            if (segment_x[0] >= trade['entry_time'] and segment_x[0] <= trade['exit_time']):
                trade_info = trade
                break
        
        hover_text = ""
        if trade_info is not None:
            hover_text = f"{trade_info['direction']} | Open: {trade_info['entry_time'].strftime('%H:%M:%S')} | Close: {trade_info['exit_time'].strftime('%H:%M:%S')}"
        
        fig.add_trace(
            go.Scatter(
                x=segment_x, 
                y=segment_y,
                mode='lines',
                line=dict(color='#1a9850', width=2),  # sötétebb zöld a jobb láthatóságért
                name='Winning Trade' if i == 0 else '',
                showlegend=i == 0,
                hoverinfo='skip',
            ),
            row=1, col=1
        )
    
    # Losing trades as red segments
    for i, (segment_x, segment_y) in enumerate(losing_segments):
        # Find the trade corresponding to this segment
        trade_info = None
        for _, trade in trades_df.iterrows():
            if (segment_x[0] >= trade['entry_time'] and segment_x[0] <= trade['exit_time']):
                trade_info = trade
                break
        
        hover_text = ""
        if trade_info is not None:
            hover_text = f"{trade_info['direction']} | Open: {trade_info['entry_time'].strftime('%H:%M:%S')} | Close: {trade_info['exit_time'].strftime('%H:%M:%S')}"
        
        fig.add_trace(
            go.Scatter(
                x=segment_x, 
                y=segment_y,
                mode='lines',
                line=dict(color='#d73027', width=2),  # sötétebb piros a jobb láthatóságért
                name='Losing Trade' if i == 0 else '',
                showlegend=i == 0,
                hoverinfo='skip',
            ),
            row=1, col=1
        )
    
    # Create a legend for proper display
    fig.add_trace(
        go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#1a9850', width=3),  # darker green
            name='Winning Trade'
        ),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#d73027', width=3),  # darker red
            name='Losing Trade'
        ),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='gray', width=1.5),
            name='No Trade'
        ),
        row=1, col=1
    )
    
    # 2nd panel: Cumulative return
    fig.add_trace(
        go.Scatter(
            x=cumulative_returns_data.index,
            y=cumulative_returns_data.values,  # Remove * 100 since values are already in percentage
            mode='lines',
            name='Cumulative Returns (%)',
            line=dict(color='#4393c3', width=2),
            hoverinfo='x+y',
        ),
        row=2, col=1
    )
    
    if date_range is not None:
        # Set x-axis range to match the date range for both subplots
        fig.update_xaxes(range=[start_date, end_date], row=1, col=1)
        fig.update_xaxes(range=[start_date, end_date], row=2, col=1)
        
    # Set dynamic y-axis ranges with 20% padding
    # For price chart
    if len(df) > 0:
        price_min = df['raw_price'].min()
        price_max = df['raw_price'].max()
        price_range = price_max - price_min
        price_padding = price_range * 0.2
        fig.update_yaxes(range=[price_min - price_padding, price_max + price_padding], row=1, col=1)
    
    # For returns chart
    if len(cumulative_returns_data) > 0:
        returns_min = cumulative_returns_data.min()
        returns_max = cumulative_returns_data.max()
        returns_range = returns_max - returns_min
        returns_padding = returns_range * 0.2
        
        # Ensure we don't go below -100% return (which is impossible)
        lower_bound = max(returns_min - returns_padding, -1)
        upper_bound = returns_max + returns_padding
        
        fig.update_yaxes(
            title_text="Cumulative Returns (%)",
            tickformat=".1%",  # Format as percentage with 1 decimal place
            row=2, col=1,
            range=[lower_bound, upper_bound]
        )
    
    # Format the chart
    fig.update_layout(
        title=title,
        template='plotly_white',
        hovermode='x unified',
        height=800,  # Appropriate height
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )
    
    # Set price scale based on date range min-max with ±20% margin
    min_price = df['raw_price'].min()
    max_price = df['raw_price'].max()
    price_range = max_price - min_price
    
    min_y = max(0, min_price - price_range * 0.20)  # 20% margin below, but not negative
    max_y = max_price + price_range * 0.20  # 20% margin above
    
    fig.update_yaxes(
        range=[min_y, max_y],
        row=1, col=1
    )
    
    # X-axis formatting and scaling
    fig.update_xaxes(
        title_text="Date",
        row=2, col=1
    )
    
    # X-axis formatting
    fig.update_xaxes(
        rangeslider_visible=False,
        rangeselector=dict(
            buttons=list([
                dict(count=5, label="5m", step="minute", stepmode="backward"),
                dict(count=15, label="15m", step="minute", stepmode="backward"),
                dict(count=30, label="30m", step="minute", stepmode="backward"),
                dict(count=1, label="1h", step="hour", stepmode="backward"),
                dict(count=6, label="6h", step="hour", stepmode="backward"),
                dict(count=1, label="1d", step="day", stepmode="backward"),
                dict(step="all")
            ]),
            x=0.01,  # Left alignment
            y=1.1,   # Place above the top panel
            xanchor="left",
            yanchor="bottom"
        ),
        row=3, col=1
    )
    
    # Create trade list HTML table
    trade_list_html = "<div style='margin-top: 20px; padding: 10px; background-color: #f8f9fa; border-radius: 5px;'>"  
    trade_list_html += "<h3>Trade List</h3>"
    trade_list_html += "<table style='width:100%; border-collapse: collapse;'>"  
    trade_list_html += "<tr style='background-color: #e9ecef;'>" \
                     "<th style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>Trade #</th>" \
                     "<th style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>Result</th>" \
                     "<th style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>Direction</th>" \
                     "<th style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>Open Time</th>" \
                     "<th style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>Close Time</th>" \
                     "<th style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>Profit %</th>" \
                     "</tr>"
    
    # Sort trades by entry time for the table
    sorted_trades = trades_df.sort_values('entry_time')
    
    for i, (_, trade) in enumerate(sorted_trades.iterrows(), 1):
        result = "Win" if trade['profit_pct'] > 0 else "Loss"
        result_color = "#1a9850" if trade['profit_pct'] > 0 else "#d73027"
        
        trade_list_html += f"<tr>" \
                         f"<td style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>{i}</td>" \
                         f"<td style='padding: 8px; text-align: left; border: 1px solid #dee2e6; color: {result_color}; font-weight: bold;'>{result}</td>" \
                         f"<td style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>{trade['direction']}</td>" \
                         f"<td style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>{trade['entry_time'].strftime('%Y-%m-%d %H:%M:%S')}</td>" \
                         f"<td style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>{trade['exit_time'].strftime('%Y-%m-%d %H:%M:%S')}</td>" \
                         f"<td style='padding: 8px; text-align: left; border: 1px solid #dee2e6;'>{trade['profit_pct']*100:.2f}%</td>" \
                         f"</tr>"
    
    trade_list_html += "</table></div>"
    
    # Save if path is provided
    if save_path:
        t_save = time.time()
        if save_path.endswith('.html'):
            html_path = save_path
        else:
            html_path = save_path if save_path.endswith('.html') else save_path + '.html'
            
        # First get the standard plotly HTML
        fig_html = fig.to_html(include_plotlyjs='cdn')
        
        # Then combine with our trade list HTML and write to file
        with open(html_path, 'w') as f:
            f.write(fig_html.replace('</body>', trade_list_html + '</body>'))
            
        print(f"Interactive chart with trade list saved: {html_path} ({time.time() - t_save:.2f}s)")
    
    return fig


def load_and_visualize_strategy(
    predictions_file: str,
    signal_threshold: int = 1,
    save_path: Optional[str] = None,
    date_range: tuple = None
) -> go.Figure:
    """
    Loads predictions, runs the trading strategy and visualizes the results
    
    Args:
        predictions_file: Path to the parquet file
        signal_threshold: How many consecutive signals are needed to start/close a trade
        save_path: Save path (if provided)
        date_range: Optional tuple of (start_datetime, end_datetime) to filter trades by date range
        
    Returns:
        plotly.graph_objects.Figure: The created interactive chart
    """
    # Initialize strategy
    strategy = SimpleTradingStrategy()
    
    # Load and preprocess data
    data = strategy.load_predictions(predictions_file)
    strategy.preprocess_data(data)
    
    # Generate trades with the specified signal threshold
    strategy.generate_trades(signal_threshold)
    
    # Analyze performance
    results = strategy.analyze_performance()
    
    # Print results
    print("\nTrading Strategy Results:")
    print("========================")
    print(f"Total trades: {results['total_trades']}")
    print(f"Winning trades: {results['winning_trades']} ({results['win_rate']*100:.2f}%)")
    print("Simple-sum return: {:.2f}%".format(results['total_return']*100))
    print(f"Average return per trade: {results['avg_return']*100:.2f}%")
    print(f"Average trade duration: {results['avg_trade_duration']:.2f} seconds")
    print(f"Median trade duration: {results['median_trade_duration']:.2f} seconds")
    print(f"Sharpe ratio: {results['sharpe_ratio']:.2f}")
    print(f"Maximum drawdown: {results['max_drawdown']*100:.2f}%")
    print(f"Buy and Hold Return: {results['buy_and_hold_return']*100:.2f}%")
    print(f"Strategy Outperformance: {results['outperformance']*100:.2f}%")
    
    # Modell név kiolvasása a fájlnévből
    model_name = os.path.basename(predictions_file).split("_")[0]
    
    # Meghatározza a megjelenítendő kereskedések számát
    if date_range is not None:
        # Ha van dátumszűrés, akkor becsüljük a szűrt kereskedések számát
        start_date, end_date = date_range
        # Convert string dates to pandas datetime if needed
        if isinstance(start_date, str):
            start_date = pd.to_datetime(start_date)
        if isinstance(end_date, str):
            end_date = pd.to_datetime(end_date)
            
        # Pre-filter trades for the title display
        filtered_trades_count = sum(
            1 for trade in strategy.trades 
            if (trade['entry_time'] >= start_date) and (trade['exit_time'] <= end_date)
        )
        title = f"Trading Strategy Performance - {model_name} (Signal Threshold: {signal_threshold}, Trades in Chart: {filtered_trades_count})"
    else:
        # Ha nincs dátumszűrés, akkor az összes kereskedés számát
        total_trades_count = len(strategy.trades)
        title = f"Trading Strategy Performance - {model_name} (Signal Threshold: {signal_threshold}, Total Trades: {total_trades_count})"
    
    # Vizualizáció létrehozása
    fig = plot_trading_strategy(
        strategy=strategy,
        title=title,
        save_path=save_path,
        date_range=date_range
    )
    
    return fig


