#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
Trading Strategy Visualization - DeepLOB trading strategy visualization.
This module enables the visualization of trades generated by the trading strategy with price data.
"""

import os
import time
import numpy as np
import pandas as pd
from plotly.subplots import make_subplots
import plotly.graph_objects as go
from typing import List, Dict, Optional, Union

# Import the trading strategy
from trading_strategy import SimpleTradingStrategy


def plot_trading_strategy(
    strategy: SimpleTradingStrategy,
    title="Price vs. Trading Strategy Performance",
    save_path=None,
    max_trades=500
) -> go.Figure:
    """
    Create a Plotly-based interactive time series chart with price data and the trading strategy's
    winning/losing trades, as well as its cumulative profit.
    
    Args:
        strategy: An initialized and executed SimpleTradingStrategy instance
        title: Chart title
        save_path: Save path (if provided)
        max_trades: Maximum number of trades to display (samples if there are too many data points)
        
    Returns:
        plotly.graph_objects.Figure: The created interactive chart
    """
    # Validation
    if strategy.data is None or len(strategy.trades) == 0:
        raise ValueError("Strategy data is missing or no trades have been generated. "
                        "First run the load_predictions, preprocess_data and generate_trades functions.")
    
    # Create DataFrame
    df = strategy.data.copy()
    
    # Convert trading data to DataFrame
    all_trades_df = pd.DataFrame(strategy.trades)
    
    # Sampling in case of too many trades
    print(f"Total number of trades: {len(all_trades_df)}")
    t_start = time.time()
    
    if len(all_trades_df) > max_trades:
        print(f"Sampling to {max_trades} trades for even display...")
        # Uniform sampling taking every nth element
        sample_step = len(all_trades_df) // max_trades
        trades_df = all_trades_df.iloc[::sample_step].copy()
        print(f"Number of sampled trades: {len(trades_df)}")
    else:
        trades_df = all_trades_df.copy()
        
    print(f"Preparation time: {time.time() - t_start:.2f}s")
    
    # Calculate cumulative returns for ALL trades (not just the sampled ones)
    # This way we see the real return, which matches the one shown in the strategy report
    all_cum_returns = (1 + all_trades_df['profit_pct']).cumprod() - 1
    
    # For visualization, we use the sampled points
    # With timestamps based on all trades
    if len(all_trades_df) > max_trades:
        # Uniform sampling for cumulative returns as well
        sample_indices = np.linspace(0, len(all_cum_returns)-1, max_trades).astype(int)
        # Then we take the appropriate data for cumulative returns
        sampled_cum_returns = all_cum_returns.iloc[sample_indices]
        sampled_exit_times = all_trades_df['exit_time'].iloc[sample_indices]
        cumulative_returns_data = pd.Series(sampled_cum_returns.values, index=sampled_exit_times)
    else:
        cumulative_returns_data = pd.Series(all_cum_returns.values, index=all_trades_df['exit_time'])
    
    # Create chart with two panels
    fig = make_subplots(
        rows=2, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.05,
        row_heights=[0.7, 0.3],
        subplot_titles=("Price with Trades", "Cumulative Return")
    )
    
    # 1st panel: Price line (gray by default, trades will be colored separately)
    fig.add_trace(
        go.Scatter(
            x=df.index,
            y=df['raw_price'],
            mode='lines',
            name='BTC Price (No Trade)',
            line=dict(color='gray', width=1.5),
            hoverinfo='skip',
        ),
        row=1, col=1
    )
    
    # Price with colored segments during trading periods
    winning_segments = []
    losing_segments = []
    no_trade_segments = []
    
    print(f"Total return for all trades: {all_cum_returns.iloc[-1]*100:.2f}%")
    
    # First sort trades by time
    trades_df = trades_df.sort_values('entry_time')
    
    # Initial timestamp
    current_time = df.index[0]
    price_data = df['raw_price']
    
    # Process trades
    for _, trade in trades_df.iterrows():
        # From previous timestamp to trade start (if there's a time difference)
        mask = (df.index >= current_time) & (df.index < trade['entry_time'])
        if mask.any():
            segment_x = df.index[mask]
            segment_y = df['raw_price'][mask]
            if len(segment_x) > 0:
                no_trade_segments.append((segment_x, segment_y))
        
        # For the trading period - only if there's data
        mask = (df.index >= trade['entry_time']) & (df.index <= trade['exit_time'])
        if mask.any():
            segment_x = df.index[mask]
            segment_y = df['raw_price'][mask]
            if len(segment_x) > 0:
                if trade['profit_pct'] > 0:
                    winning_segments.append((segment_x, segment_y))
                else:
                    losing_segments.append((segment_x, segment_y))
        
        # Set the current timestamp to the end of the trade
        current_time = trade['exit_time']
    
    # From the end of the last trade to the end of data (if there's still time)
    mask = (df.index >= current_time)
    if mask.any():
        segment_x = df.index[mask]
        segment_y = df['raw_price'][mask]
        if len(segment_x) > 0:
            no_trade_segments.append((segment_x, segment_y))
    
    # Winning trades as green segments
    for i, (segment_x, segment_y) in enumerate(winning_segments):
        # Find the trade corresponding to this segment
        trade_info = None
        for _, trade in trades_df.iterrows():
            if (segment_x[0] >= trade['entry_time'] and segment_x[0] <= trade['exit_time']):
                trade_info = trade
                break
        
        hover_text = ""
        if trade_info is not None:
            hover_text = f"{trade_info['direction']} | Open: {trade_info['entry_time'].strftime('%H:%M:%S')} | Close: {trade_info['exit_time'].strftime('%H:%M:%S')}"
        
        fig.add_trace(
            go.Scatter(
                x=segment_x, 
                y=segment_y,
                mode='lines',
                line=dict(color='#1a9850', width=2),  # sötétebb zöld a jobb láthatóságért
                name='Winning Trade' if i == 0 else '',
                showlegend=i == 0,
                hoverinfo='text',
                text=hover_text,
                hoverlabel=dict(bgcolor='#1a9850'),
            ),
            row=1, col=1
        )
    
    # Losing trades as red segments
    for i, (segment_x, segment_y) in enumerate(losing_segments):
        # Find the trade corresponding to this segment
        trade_info = None
        for _, trade in trades_df.iterrows():
            if (segment_x[0] >= trade['entry_time'] and segment_x[0] <= trade['exit_time']):
                trade_info = trade
                break
        
        hover_text = ""
        if trade_info is not None:
            hover_text = f"{trade_info['direction']} | Open: {trade_info['entry_time'].strftime('%H:%M:%S')} | Close: {trade_info['exit_time'].strftime('%H:%M:%S')}"
        
        fig.add_trace(
            go.Scatter(
                x=segment_x, 
                y=segment_y,
                mode='lines',
                line=dict(color='#d73027', width=2),  # sötétebb piros a jobb láthatóságért
                name='Losing Trade' if i == 0 else '',
                showlegend=i == 0,
                hoverinfo='text',
                text=hover_text,
                hoverlabel=dict(bgcolor='#d73027'),
            ),
            row=1, col=1
        )
    
    # Create a legend for proper display
    fig.add_trace(
        go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#1a9850', width=3),  # darker green
            name='Winning Trade'
        ),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='#d73027', width=3),  # darker red
            name='Losing Trade'
        ),
        row=1, col=1
    )
    
    fig.add_trace(
        go.Scatter(
            x=[None], y=[None],
            mode='lines',
            line=dict(color='gray', width=1.5),
            name='No Trade'
        ),
        row=1, col=1
    )
    
    # 2nd panel: Cumulative return
    fig.add_trace(
        go.Scatter(
            x=cumulative_returns_data.index,
            y=cumulative_returns_data.values,
            mode='lines',
            name='Cumulative Return',
            line=dict(color='purple', width=2),
            fill='tozeroy',
        ),
        row=2, col=1
    )
    
    # Format the chart
    fig.update_layout(
        title=title,
        template='plotly_white',
        hovermode='x unified',
        height=800,  # Appropriate height
        legend=dict(
            orientation="h",
            yanchor="bottom",
            y=1.02,
            xanchor="right",
            x=1
        )
    )
    
    # Set price scale starting from 75k
    min_y = 75000
    max_y = df['raw_price'].max() * 1.01  # Small margin at the top
    fig.update_yaxes(
        range=[min_y, max_y],
        row=1, col=1
    )
    
    # X-axis formatting and scaling
    fig.update_xaxes(
        title_text="Date",
        row=2, col=1
    )
    # Cumulative return panel scaling - based on the full data
    min_return = min(0, all_cum_returns.min() * 1.1) if len(all_cum_returns) > 0 else -0.1
    max_return = max(0.1, all_cum_returns.max() * 1.1) if len(all_cum_returns) > 0 else 0.1
    
    fig.update_yaxes(
        title_text="Cumulative Return (%)",
        tickformat=".2%",  # More precise percentage format
        row=2, col=1,
        range=[min_return, max_return]
    )
    
    # X-axis formatting
    fig.update_xaxes(
        rangeslider_visible=False,
        rangeselector=dict(
            buttons=list([
                dict(count=5, label="5m", step="minute", stepmode="backward"),
                dict(count=15, label="15m", step="minute", stepmode="backward"),
                dict(count=30, label="30m", step="minute", stepmode="backward"),
                dict(count=1, label="1h", step="hour", stepmode="backward"),
                dict(count=6, label="6h", step="hour", stepmode="backward"),
                dict(count=1, label="1d", step="day", stepmode="backward"),
                dict(step="all")
            ]),
            x=0.01,  # Left alignment
            y=1.1,   # Place above the top panel
            xanchor="left",
            yanchor="bottom"
        ),
        row=3, col=1
    )
    
    # Save if path is provided
    if save_path:
        t_save = time.time()
        if save_path.endswith('.html'):
            fig.write_html(save_path)
        else:
            save_path_html = save_path if save_path.endswith('.html') else save_path + '.html'
            fig.write_html(save_path_html)
        print(f"Interactive chart saved: {save_path} ({time.time() - t_save:.2f}s)")
    
    return fig


def load_and_visualize_strategy(
    predictions_file: str,
    signal_threshold: int = 1,
    save_path: Optional[str] = None,
    max_trades: int = 500
) -> go.Figure:
    """
    Loads predictions, runs the trading strategy and visualizes the results
    
    Args:
        predictions_file: Path to the parquet file
        signal_threshold: How many consecutive signals are needed to start/close a trade
        save_path: Save path (if provided)
        max_trades: Maximum number of trades to display (samples if there are too many data points)
        
    Returns:
        plotly.graph_objects.Figure: The created interactive chart
    """
    # Initialize strategy
    strategy = SimpleTradingStrategy()
    
    # Load and preprocess data
    data = strategy.load_predictions(predictions_file)
    strategy.preprocess_data(data)
    
    # Generate trades with the specified signal threshold
    strategy.generate_trades(signal_threshold)
    
    # Analyze performance
    results = strategy.analyze_performance()
    
    # Print results
    print("\nTrading Strategy Results:")
    print("========================")
    print(f"Total trades: {results['total_trades']}")
    print(f"Winning trades: {results['winning_trades']} ({results['win_rate']*100:.2f}%)")
    print(f"Total return: {results['total_return']*100:.2f}%")
    print(f"Average return per trade: {results['avg_return']*100:.2f}%")
    print(f"Average trade duration: {results['avg_trade_duration']:.2f} seconds")
    print(f"Median trade duration: {results['median_trade_duration']:.2f} seconds")
    print(f"Sharpe ratio: {results['sharpe_ratio']:.2f}")
    print(f"Maximum drawdown: {results['max_drawdown']*100:.2f}%")
    print(f"Buy and Hold Return: {results['buy_and_hold_return']*100:.2f}%")
    print(f"Strategy Outperformance: {results['outperformance']*100:.2f}%")
    
    # Modell név kiolvasása a fájlnévből
    model_name = os.path.basename(predictions_file).split("_")[0]
    # Összes kereskedés száma
    total_trades_count = len(strategy.trades)
    title = f"Trading Strategy Performance - {model_name} (Signal Threshold: {signal_threshold}, Total Trades: {total_trades_count}, Max Displayed: {max_trades})"
    
    # Vizualizáció létrehozása
    fig = plot_trading_strategy(
        strategy=strategy,
        title=title,
        save_path=save_path,
        max_trades=max_trades
    )
    
    return fig


